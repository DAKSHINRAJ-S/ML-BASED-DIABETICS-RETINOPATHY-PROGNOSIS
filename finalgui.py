# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'final.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import numpy as np
from keras.preprocessing import image
from keras.models import Sequential
from keras.layers import Dense
from keras.models import model_from_json
import os
import cv2
import pandas as pd



class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1571, 825)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.TITLE = QtWidgets.QLabel(self.centralwidget)
        self.TITLE.setGeometry(QtCore.QRect(750, 70, 391, 31))
        self.TITLE.setObjectName("TITLE")
        self.IMAGESHOW = QtWidgets.QLabel(self.centralwidget)
        self.IMAGESHOW.setGeometry(QtCore.QRect(740, 220, 391, 201))
        self.IMAGESHOW.setFrameShape(QtWidgets.QFrame.Box)
        self.IMAGESHOW.setText("")
        self.IMAGESHOW.setObjectName("IMAGESHOW")
        self.SELECT_IMAGE = QtWidgets.QPushButton(self.centralwidget)
        self.SELECT_IMAGE.setGeometry(QtCore.QRect(740, 460, 161, 31))
        self.SELECT_IMAGE.setObjectName("SELECT_IMAGE")
        self.CLASSIFY = QtWidgets.QPushButton(self.centralwidget)
        self.CLASSIFY.setGeometry(QtCore.QRect(970, 460, 161, 31))
        self.CLASSIFY.setObjectName("CLASSIFY")
        self.PREDICTION = QtWidgets.QLabel(self.centralwidget)
        self.PREDICTION.setGeometry(QtCore.QRect(750, 520, 151, 31))
        self.PREDICTION.setObjectName("PREDICTION")
        self.PREDICT_OUTPUT = QtWidgets.QLabel(self.centralwidget)
        self.PREDICT_OUTPUT.setGeometry(QtCore.QRect(930, 520, 201, 31))
        self.PREDICT_OUTPUT.setFrameShape(QtWidgets.QFrame.Box)
        self.PREDICT_OUTPUT.setText("")
        self.PREDICT_OUTPUT.setObjectName("PREDICT_OUTPUT")
        self.TYPE = QtWidgets.QLabel(self.centralwidget)
        self.TYPE.setGeometry(QtCore.QRect(750, 570, 131, 21))
        self.TYPE.setObjectName("TYPE")
        self.TYPE_OUTPUT = QtWidgets.QLabel(self.centralwidget)
        self.TYPE_OUTPUT.setGeometry(QtCore.QRect(930, 570, 201, 31))
        self.TYPE_OUTPUT.setFrameShape(QtWidgets.QFrame.Box)
        self.TYPE_OUTPUT.setText("")
        self.TYPE_OUTPUT.setObjectName("TYPE_OUTPUT")
        self.PERCENTAGE = QtWidgets.QLabel(self.centralwidget)
        self.PERCENTAGE.setGeometry(QtCore.QRect(750, 620, 131, 21))
        self.PERCENTAGE.setObjectName("PERCENTAGE")
        self.PERCENTAGE_OUTPUT = QtWidgets.QLabel(self.centralwidget)
        self.PERCENTAGE_OUTPUT.setGeometry(QtCore.QRect(930, 620, 201, 31))
        self.PERCENTAGE_OUTPUT.setFrameShape(QtWidgets.QFrame.Box)
        self.PERCENTAGE_OUTPUT.setText("")
        self.PERCENTAGE_OUTPUT.setObjectName("PERCENTAGE_OUTPUT")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1571, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.SELECT_IMAGE.clicked.connect(self.loadImage)
        self.CLASSIFY.clicked.connect(self.classifyFunction)



    def loadImage(self):
        fileName, _ = QtWidgets.QFileDialog.getOpenFileName(None, "Select Image", "", "Image Files (*.png *.jpg *jpeg *.bmp);;All Files (*)") # Ask for file
        if fileName: # If the user gives a file
            print(fileName)
            self.file=fileName
            pixmap = QtGui.QPixmap(fileName) # Setup pixmap with the provided image
            pixmap = pixmap.scaled(self.IMAGESHOW.width(), self.IMAGESHOW.height(), QtCore.Qt.KeepAspectRatio) # Scale pixmap
            self.IMAGESHOW.setPixmap(pixmap) # Set the pixmap onto the label
            self.IMAGESHOW.setAlignment(QtCore.Qt.AlignCenter) # Align the label to center
    

    def classifyFunction(self):
        from sklearn.metrics import accuracy_score
        
        json_file = open('model1.json', 'r')
        loaded_model_json = json_file.read()
        json_file.close()
        model = model_from_json(loaded_model_json)
        model.load_weights("model1.h5")
        print("Loaded model from disk")
        path2=self.file
        test_image = image.load_img(path2, target_size = (128, 128))
        test_image = image.img_to_array(test_image)
        test_image = np.expand_dims(test_image, axis=0)
        result = model.predict(test_image)
        #print(result)
        a=np.round(result[0][0])
        b=np.round(result[0][1])
        c=np.round(result[0][2])
        d=np.round(result[0][3])
        e=np.round(result[0][4])
        
        print(a)
        print(b)
        print(c)
        print(d)
        print(e)
        
        try:
            if a  == 1:
                prediction = 'affected'
                PREDICTION=prediction
                self.PREDICT_OUTPUT.setText(PREDICTION)
                types = 'aneurysms'
                TYPE = types
                self.TYPE_OUTPUT.setText(TYPE)
              
                img = cv2.imread(path2)
                dataset = pd.read_csv("retinopathy.csv")
                print(dataset)
                x = dataset.iloc[:,:-1] #independent
                y = dataset.iloc[:,-1] #dependent 
                from sklearn.model_selection import train_test_split
                X_train, X_test, Y_train, Y_test = train_test_split(x,y, test_size=0.80, random_state=0)
                print(X_train)
                print(Y_train)
                print(X_test)
                print(Y_test)
                from sklearn.neighbors import KNeighborsClassifier
                classifier = KNeighborsClassifier(n_neighbors=5)
                classifier.fit(X_train, Y_train)
                Y_predict = classifier.predict(X_test)
                acc = accuracy_score(Y_test, Y_predict, normalize=False)
                print("classification accuracy for diabetic retinopathy is = ",acc)
                from sklearn.metrics import classification_report
                print(classification_report(Y_test, Y_predict))
                img = cv2.resize(img,(400,400))
                #cv2.imshow("Original Frame",img)
                ## convert to hsv
                hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
                #cv2.imshow("hsv",hsv)
                ## mask of red (36,0,0) ~ (70, 255,255)
                mask1 = cv2.inRange(hsv, (0,0,100), (0,0,255)) #red
                #cv2.imshow("mask1",mask1)
                red= cv2.countNonZero(mask1)
                print("red = ",red)
                img = cv2.GaussianBlur(img,(5,5),2)
                im_gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
                ret,thresh = cv2.threshold(im_gray,127,255,0)
                count = cv2.countNonZero(thresh)
                #print(count)
                RED=((red+count)/2)*0.001000
                contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
                for contour in contours:
                    cv2.drawContours(im_gray, contours, -1, (0,255,0), 6)
                    #cv2.imshow("contour",im_gray)
                output = classifier.predict([[red]])
                print("Predicted New Output = ",output)
                if output == 1:
                    print("Affected")
                RED=int(RED)
                if RED <11:
                    RED= int(RED)
                PERCENTAGE=str(RED)
                self.PERCENTAGE_OUTPUT.setText(PERCENTAGE)
                
            elif b  == 1:
                prediction = 'affected'
                PREDICTION=prediction
                self.PREDICT_OUTPUT.setText(PREDICTION)
                types = 'exudates'
                TYPE = types
                self.TYPE_OUTPUT.setText(TYPE)
                
                img = cv2.imread(path2)
                dataset = pd.read_csv("retinopathy.csv")
                print(dataset)
                x = dataset.iloc[:,:-1] #independent
                y = dataset.iloc[:,-1] #dependent 
                from sklearn.model_selection import train_test_split
                X_train, X_test, Y_train, Y_test = train_test_split(x,y, test_size=0.80, random_state=0)
                print(X_train)
                print(Y_train)
                print(X_test)
                print(Y_test)
                from sklearn.neighbors import KNeighborsClassifier
                classifier = KNeighborsClassifier(n_neighbors=5)
                classifier.fit(X_train, Y_train)
                Y_predict = classifier.predict(X_test)        
                img = cv2.resize(img,(400,400))
                #cv2.imshow("Original Frame",img)
                ## convert to hsv
                hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
                #cv2.imshow("hsv",hsv)
                ## mask of red (36,0,0) ~ (70, 255,255)
                mask1 = cv2.inRange(hsv, (0,0,100), (0,0,255)) #red
                #cv2.imshow("mask1",mask1)
                red= cv2.countNonZero(mask1)
                print("red = ",red)
                img = cv2.GaussianBlur(img,(5,5),2)
                im_gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
                ret,thresh = cv2.threshold(im_gray,127,255,0)
                count = cv2.countNonZero(thresh)
                #print(count)
                RED=((red+count)/2)*0.001000
                contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
                for contour in contours:
                    cv2.drawContours(im_gray, contours, -1, (0,255,0), 6)
                    #cv2.imshow("contour",im_gray)
                output = classifier.predict([[red]])
                print("Predicted New Output = ",output)
                if output == 1:
                    print("Affected")
                RED=int(RED)
                if RED <11:
                    RED= int(RED)
                PERCENTAGE=str(RED)
                self.PERCENTAGE_OUTPUT.setText(PERCENTAGE)

            elif c  == 1:
                prediction = 'affected'
                PREDICTION=prediction
                self.PREDICT_OUTPUT.setText(PREDICTION)
                types = 'hemorrhages'
                TYPE = types
                self.TYPE_OUTPUT.setText(TYPE)
                
                img = cv2.imread(path2)
                dataset = pd.read_csv("retinopathy.csv")
                print(dataset)
                x = dataset.iloc[:,:-1] #independent
                y = dataset.iloc[:,-1] #dependent 
                from sklearn.model_selection import train_test_split
                X_train, X_test, Y_train, Y_test = train_test_split(x,y, test_size=0.80, random_state=0)
                print(X_train)
                print(Y_train)
                print(X_test)
                print(Y_test)
                from sklearn.neighbors import KNeighborsClassifier
                classifier = KNeighborsClassifier(n_neighbors=5)
                classifier.fit(X_train, Y_train)
                Y_predict = classifier.predict(X_test)        
                img = cv2.resize(img,(400,400))
                #cv2.imshow("Original Frame",img)
                ## convert to hsv
                hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
                #cv2.imshow("hsv",hsv)
                ## mask of red (36,0,0) ~ (70, 255,255)
                mask1 = cv2.inRange(hsv, (0,0,100), (0,0,255)) #red
                #cv2.imshow("mask1",mask1)
                red= cv2.countNonZero(mask1)
                print("red = ",red)
                img = cv2.GaussianBlur(img,(5,5),2)
                im_gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
                ret,thresh = cv2.threshold(im_gray,127,255,0)
                count = cv2.countNonZero(thresh)
                #print(count)
                RED=((red+count)/2)*0.001000
                contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
                for contour in contours:
                    cv2.drawContours(im_gray, contours, -1, (0,255,0), 6)
                    #cv2.imshow("contour",im_gray)
                output = classifier.predict([[red]])
                print("Predicted New Output = ",output)
                if output == 1:
                    print("Affected")
                RED=int(RED)
                if RED <11:
                    RED= int(RED)
                PERCENTAGE=str(RED)
                self.PERCENTAGE_OUTPUT.setText(PERCENTAGE)
                
            elif d  == 1:
                prediction = 'affected'
                PREDICTION=prediction
                self.PREDICT_OUTPUT.setText(PREDICTION)
                types = 'microaneurysms'
                TYPE = types
                self.TYPE_OUTPUT.setText(TYPE)
                
                img = cv2.imread(path2)
                dataset = pd.read_csv("retinopathy.csv")
                print(dataset)
                x = dataset.iloc[:,:-1] #independent
                y = dataset.iloc[:,-1] #dependent 
                from sklearn.model_selection import train_test_split
                X_train, X_test, Y_train, Y_test = train_test_split(x,y, test_size=0.80, random_state=0)
                print(X_train)
                print(Y_train)
                print(X_test)
                print(Y_test)
                from sklearn.neighbors import KNeighborsClassifier
                classifier = KNeighborsClassifier(n_neighbors=5)
                classifier.fit(X_train, Y_train)
                Y_predict = classifier.predict(X_test)        
                img = cv2.resize(img,(400,400))
                #cv2.imshow("Original Frame",img)
                ## convert to hsv
                hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
                #cv2.imshow("hsv",hsv)
                ## mask of red (36,0,0) ~ (70, 255,255)
                mask1 = cv2.inRange(hsv, (0,0,100), (0,0,255)) #red
                #cv2.imshow("mask1",mask1)
                red= cv2.countNonZero(mask1)
                print("red = ",red)
                img = cv2.GaussianBlur(img,(5,5),2)
                im_gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
                ret,thresh = cv2.threshold(im_gray,127,255,0)
                count = cv2.countNonZero(thresh)
                #print(count)
                RED=((red+count)/2)*0.001000
                contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
                for contour in contours:
                    cv2.drawContours(im_gray, contours, -1, (0,255,0), 6)
                    #cv2.imshow("contour",im_gray)
                output = classifier.predict([[red]])
                print("Predicted New Output = ",output)
                if output == 1:
                    print("Affected")
                RED=int(RED)
                if RED <11:
                    RED= int(RED)
                PERCENTAGE=str(RED)
                self.PERCENTAGE_OUTPUT.setText(PERCENTAGE)
                  
                    
              
            elif e  == 1:
                prediction = 'normal'
                PREDICTION=prediction
                self.PREDICT_OUTPUT.setText(PREDICTION)
                TYPE = ''
                self.TYPE_OUTPUT.setText(TYPE)
                PERCENTAGE='0'
                self.PERCENTAGE_OUTPUT.setText(PERCENTAGE)
                  




        except Exception as f:
            print(f)
        

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.TITLE.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:10pt; font-weight:600;\">DIABETIC RETINOPATHY CLASSIFICATION </span></p></body></html>"))
        self.SELECT_IMAGE.setText(_translate("MainWindow", "SELECT IMAGE"))
        self.CLASSIFY.setText(_translate("MainWindow", "CLASSIFICATION"))
        self.PREDICTION.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:10pt; font-weight:600;\">PREDICTION</span></p></body></html>"))
        self.TYPE.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:10pt; font-weight:600;\">TYPES</span></p><p><br/></p></body></html>"))
        self.PERCENTAGE.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:10pt; font-weight:600;\">PERCENTAGE</span></p></body></html>"))


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
